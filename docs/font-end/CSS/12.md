# 方法论

## 列举 CSS3 新特性

面试高频指数：★★★☆☆

### 什么是 CSS3？

自 CSS2.1 后，CSS 标准被拆解成多个模块，每个模块有自己的版本并独立更新

CSS3 泛指这些模块的总和，作为 CSS 的第 3 版本的 CSS3 事实上已不存在

### 什么是 CSS3 新特性？

CSS 标准的各个模块都在快速更新，其中已经进入到候选推荐、建议推荐和推荐 的模块被称为稳定模块

稳定模块中新增的特性大多已获得浏览器广泛支持，使用不需要加私有前缀

这里的新特性通常指这些模块中新增的标准

### CSS3 新特性有哪些，举例说明？

- 颜色模块
  - 新增`opacity`属性
  - 新增`hsl()` `hsla()` `rgb()` `rgba()`方法
  - 新增 颜色关键字 currentColor
  - 定义`transparent`为`rgb(0, 0, 0, 0.0)`
- 选择器模块
  - 新增 属性选择器：`[attribute^="value"]` `[attribute$="value"]` `[attribute*="value"]`
  - 新增 伪类：`:target` `:enabled` `:disabled` `:checked` `:indeterminate` `:root` `:nth-child` `:nth-last-child` `:nth-of-type` `:nth-last-of-type` `:last-child` `:first-of-type` `:last-of-type` `:only-child` `:only-of-type` `:empty` `:not`
  - 新增 普通兄弟选择器：`~`
  - 规范 伪元素表示为两个冒号：`::after` `::before` `::first-letter` `::first-line`
- 命名空间模块
  - 新增 @规则：`@namespace`
- 媒体查询模块
  - 支持更多媒体查询条件：`tv` `color` `resolution`等
  - 支持`<link>`标签的媒体查询
- 背景和边框模块
  - 支持渐变`linear-gradient`背景
  - 支持多背景图片
  - 新增`background-origin` `background-size` `background-clip`
  - 新增 圆角边框：`border-radius`
  - 新增 边框图片：`border-image`
  - 新增 边框阴影：`box-shadow`
- 多列布局模块
  - 支持多列布局：`columns` `column-count` `column-width`等
- 值和单位模块
  - 新增 相对长度单位：`rem` `ch` `vw` `vh` `vmax` `vmin`
  - 新增方法：`calc()`
- 弹性盒布局模块
  - 支持弹性布局：`dispaly:flex` `flex-direction` `flex-wrap`等
- 文本装饰模块
  - 新增 着重符号：`text-emphasis`
  - 新增 文本阴影：`text-shadow`

## 什么是 CSS 组件化和原子化？

面试高频指数：★★☆☆☆

### 组件化

CSS 组件是样式页面样式可复用的最小元素组合

过去，前端常会按照页面结构，将公共部分提取成组件，方便在其它页面调用

**好处**：

- 无需重复编写 CSS，结构级别的复用
- 保持风格统一
- 一次修改，所有页面都生效
- 通过新建修饰符类的方式，个性化组件

**缺陷**：

- 限制设计师发挥，设计师可能需要先参考组件库已有组件的设计
- 需要个性化的属性较多时，修饰原有组件和新建组件，都可能产生新的代码冗余
- 组件库随项目越来越大，逐渐难以维护

### 原子化

CSS 原子化的每个原子类，几乎只包含一种属性定义

这些原子类可以继续组合，生成属性更丰富的组件类

前端更关注不同元素间的相同属性，即使这些元素的结构完全不同

**好处**：

- 无需重复编写 CSS，属性级别的复用
- 保持风格统一
- 一次修改，所有页面都生效
- 更灵活，设计师可以发挥，前端可以自由组合
- 类名与业务松耦合，甚至可以为不同业务定制
- 组件的样式一目了然，容易维护

**缺陷**：

- 无统一标准，类名自己起，他人使用需要学习成本
- HTML 类名顺序，无法决定 CSS 优先级，HTML 在后面的类名，可能因为在 CSS 定义中在前，相同属性的值被 CSS 定义中后面的类名覆盖。违反心智模型
- 项目较小时，编写原子库不经济

**CSS-in-JS 改进原子化缺陷**

- 类名无统一标准，需要学习

  类名由 JS 根据内容生成，相同 CSS 的类名相同，不同 CSS 的类名不同且唯一，前端不用起类名

- 使 HTML 类名顺序生效

  原子类只有一个属性，这意味着，我们把 CSS 类定义写进 JS，由 JS 根据 类名顺序，若属性名重复，则采用最后出现的属性值

- 此外，CSS-in-JS 还将样式与组件放到一起，能够从根本上避免组件移除，而样式忘记移除的问题

原子化思想早已有之，Atomic CSS 和 tailwindcss 最有代表性

更多组件库并不是只用组件化或原子化，而是通过组件化提供易用的组件和有限的可定制接口，通过原子化提供响应式布局、边距、颜色、字体等细粒度控制类 在工作中，组件化和原子化都能满足绝大多数的业务场景，是否应用更多地受设计思想和开发习惯的影响

对于业务组件来说，使用公用原子类，影响组件的独立性。而仅在组件内部使用原子类，又会大大降低原子类的优势

开发业务类组件，使用组件化的 CSS 依然是首选，除非我们决定引入或定义一套原子类 CSS，作用于整个组件库

长期来看，原子化正越来越得到关注，结合 CSS-in-JS 的原子化未来可期

## 对比多种编写规则

面试高频指数：★★☆☆☆

OOCSS，SMACSS，BEM，ITCSS，Utility-First CSS，ACSS 都是 CSS 编写规则，是结构化编写和组织 CSS 的指南，掌握一种 CSS 方法论，更利于他人理解您的代码和团队协作

### OOCSS

面向对象的 CSS ，全称是 Object Oriented CSS  
我们把样式重复的代码片段，定义为 CSS 对象

- 盒模型与皮肤无关：盒模型属性与颜色、背景等皮肤主题属性分选择器定义
- 样式与位置无关：避免使用标签、关系选择器
  应用时，我们通常提取多个元素的公用属性，作为基本类
  在其基础上，通过其它类扩展每个元素的个性属性
  这是避免 CSS 代码冗余的常用方法

### SMACSS

可扩展模块化 CSS 架构，全称是 Scalable and Modular Architecture for CSS  
定义了 CSS 分类和命名规则，并对 CSS 书写提出优化建议

- Base：默认，基础，通用规则，包括重置浏览器样式的规则
- Layout：布局规则，以 `l-`或 `layout-`开头
- Module：可复用模块规则
- State：布局或模块的特殊状态规则，如隐藏，激活等，以 `is` 开头
- Theme：皮肤或主题规则，可能包含另一种配色方案

### BEM

块元素修饰符，全称是 Block Element Modifier  
定义了一种 CSS 的命名规则，用于解决命名冲突：

```
.block-name__element-name--modifier-name
.块名__元素名--修饰符（元素名和修饰符都可为空）
```

其中：

- Block：块，忽略结构和优先级，具有独立意义的实体
- Element：元素，块内部没有独立意义的实体
- Modifier：修饰符，标识块或元素的外观、行为、状态被修改
  含有修饰符的类名不可独立出现，通常跟在不含修饰符的类名后

### ITCSS

倒三角形 CSS，全称是 Inverted Triangle CSS，主要用 SASS 实现  
提供了一种 CSS 由通用到具体的分层（分类）方法，层次可以按需增删：

- Settings：全局变量、方法
- Tools：全局使用函数、混入器
- Generic：浏览器默认样式重置
- Base：仅可使用类型（标签）选择器
- Objects：遵循 OOCSSS 的对象的盒模型，无颜色、背景等
- Components：可复用的组件
- Trumps：对组件的微调和其他样式定义，可使用 !important

### Utility-First CSS

实用类优先 CSS  
提供了一种外观组件的构建方法，以 tailwindcss 为代表

- 按照一定规则，基于 CSS 实用类构建复杂外观组件
- 不用起类名
- 样式文件体积不会随项目无限增长
- 增删类名，比直接修改属性更安全，维护更容易

### ACSS

原子 CSS，全称是 Atomic CSS，可以看成 Utility-First CSS 的极致抽象  
提供了一种 CSS 类的定义方法，提升大型项目 CSS 复用度

- 每个类选择器中只包含一条属性定义，一次编写，到处运行
- 属性名类似函数，属性值类似函数参数，像写内联样式一样写类名，适合 CSS-in-JS
- 提供工具，可按需编译

## CSS 属性的建议书写顺序，为什么？

面试高频指数：★★☆☆☆

### 为什么要规定 CSS 属性的书写顺序？

以前，我们规定 CSS 属性的书写顺序，期望其浏览器浏览器渲染顺序，减少不必要的重排和重绘  
浏览器渲染流程如下：

![render](/images/render.png)

① 解析 HTML 为 DOM Tree  
② 解析 CSS 为 CSSOM  
③ 深度遍历 Dom Tree，适配 CSSOM。计算样式。将可见节点内容和计算后的样式放入 Render Tree  
④ 布局 Render Tree  
⑤ 绘制 Render Tree  
⑥ 合成 Render Tree  
⑦ 重排 Reflow  
⑧ 重绘 RePaint

现代浏览器可以边下载边进行第 ① 到 ⑤ 渲染，开发者也可以手动实现 DOM 懒加载 对单个样式的修改，不会马上引起重排或重绘，而是会加入队列

当队列达到一定长度或一定时间后统一渲染，综上：  
① 虽然 CSS 按书写顺序解析，但书写顺序对渲染的影响已经很小  
② 有助于提升代码的可读性，可维护性，利于团队协作  
③ 有效避免重复或遗漏声明属性  
④ 避免实验中的私有属性与已加入规范的属性在具体实现的冲突

### 合适的 CSS 属性书写顺序是？

根据浏览器的渲染顺序，我们总是将影响元素文档流占位的属性提前，参考 @mdo 的 CSS 编码规范：  
① 定位属性  
② 盒模型  
③ 排版属性  
④ 视觉属性  
⑤ 杂项属性  
遇到私有属性和标准属性时，将私有属性放在前面

每个属性的具体顺序，可以参考推特或其他的 CSS 规范
