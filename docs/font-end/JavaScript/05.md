# 全栈

## Node.js

### express 中 next 的作用？

next 是 中间件函数的第三参数

- 执行 next()，控制权交给下个中间件
- 不执行
  - 终止请求
  - 挂起请求

### 对比 express 和 koa？

- Handler 处理方式
  - Express：回调函数
  - Koa：Async / Await
- 中间件
  - Express：同一线程，线性传递
  - Koa：洋葱模型，级联传递
- 响应机制
  - Express：`res.send` 立即响应
  - Koa：设置 `ctx.body`，可累加，经过中间件后响应

## 计算机网络

### 对比持续通信的方法？

#### 轮询

- 通过 setInterval 或 setTimeout 定时获取并刷新页面上的数据
- 定时查询，不一定有新数据
- 并发较多时，增加服务器负担

#### 长连接

- 页面其纳入 iframe，将 src 设为长连接
- 减少无用请求
- 并发较多时，增加服务器负担

#### 长轮询

- 服务端收到请求后，hold 住链接，直到新消息返回时才响应
- 减少无用请求
- 返回数据顺序无保证

#### Flash Socket

- 客户端通过嵌入 Socket 类 Flash 与服务器端的 Socket 接口通信
- 真正即时通信
- 非 HTTP 协议，无法自动穿越防火墙

#### WebSocket

- 在客户端和服务器间打开交互式通信绘话
- 兼容 HTTP 协议。与 HTTP 同属应用层。默认端口是 80 和 443
- 建立在 TCP 协议基础之上，与 HTTP 协议同属于应用层
- 数据格式轻量，性能开销小，通信高效
- 可以发送文本，也可以发送二进制数据
- **没有同源限制**
- 协议表示符：ws，加密 wss

#### socket.io

- 跨平台的 WebSocket 库，API 前后端一致，可以触发和响应自定义事件

```js
// 服务端
const io = require('socket.io')(3000)
io.on('connection', (socket) => {
  socket.on('update item', (arg1, arg2, callback) => {
    console.log(arg1, arg2)
    callback({ status: 'fulfilled' })
  })
})
// 客户端
const socket = io()
socket.emit('update item', '1', { name: 'updated' }, (res) => {
  console.log(res.status) // ok
})
```

### 网络结构按五层和七层分别是？

TCP / IP 体系结构

- 网络接口层
- 网际层 IP
- 运输层 TCP 或 UDP
- 应用层（TELNET FTP SMTP 等）

五层

- 物理层
- 数据链路层
- 网络层
- 运输层
- 应用层

七层：Open System Inerconnect Reference Model 开放式系统互联通信参考模型

- 物理层
- 数据链路层
- 网络层
- 传输层
- 会话层
- 表达层
- 应用层

### 什么是 TCP 三次握手，为什么要三次握手？

#### （1）什么是 TCP 三次握手？

- 起初
  - 客户端 CLOSED
  - 服务端 CLOSED
- 第一次握手
  - 客户端发送请求报文
    - 传输自身通讯初始序号
    - 客户端 SYN-SENT
- 第二次握手
  - 服务器接收请求报文
    - 同意连接
      - 传输自身通讯初始序号
      - 服务端 SYN-RECEIVED
    - 拒绝连接
      - 服务端 REFUSED
- 第三次握手
  - 客户端接收应答报文
    - 客户端发送确认报文
    - 客户端 ESTABLISHED
  - 服务端接收确认报文
    - 服务端 ESTABLISHED

#### （2）为什么要三次握手？

- 客户端首次发送请求无应答，TCP 启动超时重传
- 服务器收到重传的请求，建立连接，接收数据，关闭连接
- 服务器收到客户端首次发送请求，再次建立连接，但客户端已经关闭连接

需要三次握手，客户端发送确认报文后再建立连接，避免重复建立连接

### 浏览器有哪些请求方法？

安全：请求会影响服务器资源

幂等：多次执行重复操作，结果相同

| 方法    | 描述                                  | 请求体 | 响应体 | 支持表单 | 安全 | 幂等 | 可缓存                        |
| ------- | ------------------------------------- | ------ | ------ | -------- | ---- | ---- | ----------------------------- |
| GET     | 请求资源                              | 无     | 有     | 是       | 是   | 是   | 是                            |
| HEAD    | 请求资源头部                          | 无     | 无     | 否       | 是   | 是   | 是                            |
| POST    | 发送数据 数据类型由 Content-Type 指定 | 有     | 有     | 是       | 否   | 否   | 响应头包含 expires 和 max-age |
| PUT     | 发送负载创建或替换目标资源            | 有     | 无     | 否       | 否   | 是   | 否                            |
| DELETE  | 删除资源                              | 不限   | 不限   | 否       | 否   | 是   | 否                            |
| CONNECT | 创建点到点沟通隧道                    | 无     | 有     | 否       | 否   | 否   | 否                            |
| OPTIONS | 检测服务器支持方法                    | 无     | 有     | 否       | 是   | 是   | 否                            |
| TRACE   | 消息环路测试 多用于路由检测           | 无     | 无     | 否       | 是   | 是   | 否                            |
| PATCH   | 部分修改资源                          | 有     | 有     | 否       | 否   | 否   | 否                            |

### 提交表单的内容类型有哪些？

- application/x-www-form-urlencoded：初始的默认值

```
Content-Type：application/x-www-form-urlencoded
...
key1=value1&key2=value2
```

- multipart/form-data：适用于使用 `<input>` 标签上传的文件

```
Content-Type：multipart/form-data; boundary=------数据边界值
...
------数据边界值
Content-Disposition: form-data; name="key1"
value1
------数据边界值
Content-Disposition: form-data; name="key2"
value2
```

- text/plain：HTML5 引入类型

```
Content-Type：text/plain
...
key1=value1
key2=value2
```

### docker 与虚拟机区别

#### 启动速度

- Docker：秒级启动
- 虚拟机：几分钟启动

#### 需要资源

- Docker：操作系统级别虚拟化，与内核直接交互，几乎没有性能损耗
- 虚拟机：
  - 通过虚拟机监视器（Virtual machine monitor，VMM，Hypervisor）
  - 厂商：Citrix XenServer，Hyper-V，开源 KVM 、Xen、VirtualBSD

#### 轻量

- Docker：内核与应用程序库可共享，占用内存极小，资源利用率高
- 虚拟机：同样硬件环境，Docker 运行的镜像数量远多于 虚拟机数量

#### 安全性

- Docker：安全性更弱。租户 root 与宿主机 root 等同，有提权安全风险
- 虚拟机：
  - 租户 root 权限与宿主机的 root 虚拟机权限分离
  - 用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术，虚拟机难以突破 VMM 直接与宿主或彼此交互

#### 可管理型

- Docker：集中化管理工具还不算成熟
- 虚拟机：拥有相对完备的集中化管理工具

#### 高可用和可恢复性

- Docker：依靠 快速重新部署 实现
- 虚拟机：负载均衡、高可用、容错、迁移、数据保护，VMware 可承诺 SLA（服务级别协议）99.999% 高可用

#### 快速创建、删除

- Docker：秒级别，开发、测试、部署更快
- 虚拟机：分钟级别

#### 交付、部署

- Docker：在 Dockerfile 中记录了容器构建过程，可在集群中实现快速分发和快速部署
- 虚拟机：支持镜像

### 对比 Intel 的 VT-x，VT-d，VT-c

#### VT-x

- 运行 ESXI 上的 64 位 Guest OS 基本指令
- Intel 运用 Virtualization 虚拟化技术中的指令集
- 减少 VMM 干预，硬件支持 VMM 与 Guest OS
- 需要 VMM 干预，更快速、可靠、安全切换
- 更灵活、更稳定

#### VT-d

- 使一个 Guest OS 独占并直接存取硬件设备，加快读写速度
- 开启条件：北桥芯片支持，BIOS 开启

#### VT-c

- **Virtual Machine Direct Connect**
  - 虚拟机的虚拟网络卡传送透过 VMM 来进行传输
  - Guest OS 可以直接对 实体网络 I/O 进行存取
  - 加强 VT-d，让多个虚拟机与实体 I/O 装置同时建立通道
- **Virtual Machine Direct Queues**
  - 由 VMM 管理的虚拟化 Switch 转送封包给虚拟机
    - 封包流向哪个虚拟机，需要额外 CPU 资源
  - 透过网卡内建 Layer2 classifier / sorter 加速网络资料传送
    - 在芯片里安排并通过队列排序好封包给虚拟机，不需要 VMM 支持
      - 大大降低网络负载和 CPU 使用率

## HTTP

### 什么是 URL ？

- URL （统一资源定位器）是指定在 Internet 上可以找到资源的位置的文本字符串
  - 在 HTTP 的上下文中，URL 被叫做“网络地址”或“链接”
  - 浏览器在其地址栏显示 URL，例如 [https://zoopen.cn](https://zoopen.cn)
  - URL 也可用于文件传输（FTP），电子及邮件（SMTP）和其他应用
- URL 接口用于解析、构造、规范化和编码 URLs
  - 通过调用 URL 构造函数 `new URL(url, [, base])` 创建并返回一个 URL 对象
    - 该 URL 对象引用使用绝对 URL 字符串
    - 或相对 URL 字符串和基本 URL 字符串指定的 URL
    - 通过 URL 对象读取已解析的组成部分或对 URL 进行更改
- `<url>` 是 CSS 中的一种数据类型
  - `<url>` 没有独有的表达形式，只能通过 `url()` 函数定义
  - `url()` 函数中的 URL 可以使用单引号或双引号包含，也可以直接书写
    - 使用相对地址时，相对地址相对于 CSS 样式表的 URL （而不是网页的 URL）

### 什么是 HTTP 报文？

（1）定义

HTTP 全称 Hypertext Transfer Protocol，超文本传输协议，是应用层协议

HTTP 报文由从客户端到服务器的请求和从服务器到客户端的响应构成

（2）组成

- 起始行：报文描述
- 头部：报文属性
- 主体：报文数据

（3）分类

- 请求报文：客户端到服务端发送请求
  - 请求行：方法 + URL + HTTP 协议版本
  - 通用信息头：`Connection` 等
  - 请求头
  - 实体头：POST / PUT / PATCH 的 `Content-Type` `Content-Length` 等
  - 报文主体
- 响应报文：服务端到客户端返回数据
  - 状态行：状态码 + 原因
  - 通用信息头：`Connection` 等
  - 响应头
  - 实体头：`Content-Type` `Content-Length` 等
  - 报文主体

### 常见的 HTTP 状态码有哪些？

| 状态码  | 原因                            | 说明                                                                           |
| ------- | ------------------------------- | ------------------------------------------------------------------------------ |
| 100-199 | 信息响应                        |                                                                                |
| 100     | Continue                        | 已收到请求，客户端应继续                                                       |
| 101     | Switching Protocol              | 响应客户端 Upgrade 列出协议，服务端正在切换协议                                |
| 102     | Processing                      | 服务端正在处理请求，无响应可用                                                 |
| 103     | Early Hints                     | 与 Link 一起使用，客户端应在服务端继续响应前开始预加载资源                     |
| 200-299 | 成功响应                        |                                                                                |
| 200     | OK                              | 请求成功，常见于 GET HEAD POST TRACE                                           |
| 201     | Created                         | 请求成功，新资源已创建，常见于 POST PUT                                        |
| 202     | Accepted                        | 请求已收到，但未响应                                                           |
| 203     | Non-Authoritative Information   | 响应经过了代理服务器修改                                                       |
| 204     | No Content                      | 请求已处理，无返回，客户端不更新视图                                           |
| 205     | Reset Content                   | 请求已处理，无返回，客户端应更新视图                                           |
| 206     | Partial Content                 | 请求已处理，返回部分内容，常见于视频点播、分段下载、断点续传                   |
| 300-399 | 重定向                          |                                                                                |
| 300     | Multiple Choice                 | 提供一系列地址供客户端选择重定向                                               |
| 301     | Moved Permanently               | 永久重定向，默认可缓存，搜索引擎应更新链接                                     |
| 302     | Found                           | 临时重定向，默认不缓存，除非显示指定                                           |
| 303     | See Other                       | 临时重定向，必须 GET 请求                                                      |
| 304     | Not Modified                    | 未修改，不含响应体                                                             |
| 307     | Temporary Redirect              | 临时重定向，默认不缓存，除非显示指定，不改变请求方法和请求体                   |
| 308     | Permanent Redirect              | 永久重定向，默认可缓存，搜索引擎应更新链接，不改变请求方法和请求体             |
| 400-499 | 客户端错误                      |                                                                                |
| 400     | Bad Request                     | 请求语义或参数有误，不应重复请求                                               |
| 401     | Unauthorized                    | 请求需身份验证或验证失败                                                       |
| 403     | Forbidden                       | 拒绝，不应重复请求                                                             |
| 404     | Not Found                       | 未找到，无原因                                                                 |
| 405     | Method Not Allowed              | 不允许的请求方法，并返回 Allow 允许的请求方法列表                              |
| 406     | Not Acceptable                  | 无法根据请求条件，返回响应体                                                   |
| 407     | Proxy Authentication Required   | 请求需在代理服务器上身份验证                                                   |
| 408     | Request Timeout                 | 请求超时                                                                       |
| 409     | Conflict                        | 请求冲突，响应应包含冲突原因                                                   |
| 410     | Gone                            | 资源已被永久移除                                                               |
| 411     | Length Required                 | 请求头需添加 Content-Length                                                    |
| 412     | Precondition Failed             | 非 GET POST 请求外，If-Unmodified-Since 或 If-None-Match 规定先决条件无法满足  |
| 413     | Payload Too Large               | 请求体数据大小超过服务器处理范围                                               |
| 414     | URI Too Long                    | URL 过长，查询字符串过长时，应使用 POST 请求                                   |
| 415     | Unsupported Media Type          | 请求文件类型服务端不支持                                                       |
| 416     | Range Not Satisfiable           | 请求头 Range 与资源可用范围不重合                                              |
| 417     | Expectation Failed              | 服务端无法满足客户端通过 Expect 设置的期望响应                                 |
| 421     | Misdirected Request             | HTTP2 下链接无法复用时返回                                                     |
| 425     | Too Early                       | 请求有重放攻击风险                                                             |
| 426     | Upgrade Required                | 客端应按响应头 Upgrade 的协议列表中的协议重新请求                              |
| 428     | Precondition Required           | 没有符合 If-Match 的资源                                                       |
| 429     | Too Many Requests               | 请求频次超过服务端限制                                                         |
| 431     | Request Header Fields Too Large | 请求头字段过大                                                                 |
| 451     | Unavailable For Legal Reasons   | 因法律原因该资源不可用                                                         |
| 500-511 | 服务端响应                      |                                                                                |
| 500     | Internal Server Error           | 服务端报错，通常是脚本错误                                                     |
| 501     | Not Implemented                 | 请求方法不被服务器支持                                                         |
| 502     | Bad Gateway                     | 网关无响应，通常是服务端环境配置错误                                           |
| 503     | Service Unavailable             | 服务端临时不可用，建议返回 Retry-After，搜索引擎爬虫应一段时间再次访问这个 URL |
| 504     | Gateway Timeout                 | 网关超时，通常是服务端过载                                                     |
| 505     | HTTP Version Not Supported      | 请求的 HTTP 协议版本不被支持                                                   |
| 506     | Variant Also Negotiates         | 内部服务器配置错误                                                             |
| 510     | Not Extended                    | 不支持 HTTP 扩展                                                               |
| 511     | Network Authentication Required | 需要身份验证，常见于公用 WIFI                                                  |

### 常用的 HTTP 方法有哪些，GET 和 POST 的区别是什么？

- 安全：请求方法不会影响服务器上的资源
- 幂等：多次执行相同操作，结果相同
- 显示声明缓存：响应头包含 `Expires` `Cache-Control: max-age` 等时缓存

| 方法    | 描述                                   | 请求含主体 | 响应含主体 | 支持表单 | 安全 | 幂等 | 可缓存       |
| ------- | -------------------------------------- | ---------- | ---------- | -------- | ---- | ---- | ------------ |
| GET     | 请求资源                               | 否         | 是         | 是       | 是   | 是   | 是           |
| HEAD    | 请求资源头部                           | 否         | 否         | 否       | 是   | 是   | 是           |
| POST    | 发送数据，主体类型由 Content-Type 指定 | 是         | 是         | 是       | 否   | 否   | 显式声明缓存 |
| PUT     | 发送负载创建或替换目标资源             | 是         | 否         | 否       | 否   | 是   | 否           |
| DELETE  | 删除资源                               | 不限       | 不限       | 否       | 否   | 是   | 否           |
| CONNECT | 创建点到点沟通隧道                     | 否         | 是         | 否       | 否   | 否   | 否           |
| OPTIONS | 检测服务端支持方法                     | 否         | 是         | 否       | 是   | 是   | 否           |
| TRACE   | 消息环回测试，多用于路由检测           | 否         | 否         | 否       | 是   | 是   | 否           |
| PATCH   | 部分修改资源                           | 是         | 是         | 否       | 否   | 否   | 否           |

### 常见的 HTTP 请求头和响应头有哪些？

| 请求头                    | 描述                                           | 示例                                                                                                                                           |
| ------------------------- | ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| Accept                    | 用户代理支持的 MIME 类型列表                   | Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,/;q=0.8,application/ signed-exchange;v=b3;q=0.9 |
| Accept-Encoding           | 用户代理支持的压缩方法（优先级）               | Accept-Encoding: br, gzip, deflate                                                                                                             |
| Accept-Language           | 用户代理期望的语言（优先级）                   | Accept-Language: zh-CN,zh;q=0.9                                                                                                                |
| Cache-Control             | 缓存机制                                       | Cache-Control: max-age=0                                                                                                                       |
| Connection                | 是否持久连接                                   | Connection: keep-alive                                                                                                                         |
| Cookie                    | HTTP cookies                                   | 服务器通过 Set-Cookie 存储到客户端的 Cookie                                                                                                    |
| Host                      | 主机名 + 端口号                                | Host: 127.0.0.1:8080                                                                                                                           |
| If-Match                  | 请求指定标识符资源                             | If-Match: "56a88df57772gt555gr5469a32ee75d65dcwq989"                                                                                           |
| If-Modified-Since         | 请求指定时间修改过的资源                       | If-Modified-Since: Wed, 19 Oct 2020 17:32:00 GMT                                                                                               |
| If-None-Match             | 请求非指定标识符资源                           | If-None-Match: "56a88df57772gt555gr5469a32ee75d65dcwq989"                                                                                      |
| Upgrade-Insecure-Requests | 客户端优先接受加密和有身份验证的响应，支持 CSP | Upgrade-Insecure-Requests: 1                                                                                                                   |
| User-Agent                | 用户代理                                       | User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36                |
| Vary                      | 缓存策略                                       | Vary: User-Agent 常用于自适应缓存配置和 SEO                                                                                                    |

| 响应头           | 描述               | 示例                                                                                                                                                     |
| ---------------- | ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Cache-Control    | 缓存机制           | Cache-Control: public, max-age=3600                                                                                                                      |
| Connection       | 是否持久连接       | Connection: keep-alive                                                                                                                                   |
| Content-Encoding | 内容编码方式       | Content-Encoding: br                                                                                                                                     |
| Content-Type     | 内容的 MIME 类型   | Content-Type: text/html; charset=UTF-8                                                                                                                   |
| Date             | 报文创建时间       | Date: Sun, 28 Feb 2021 11:52:51 GMT                                                                                                                      |
| Expires          | 资源过期时间       | Expires: Sun, 28 Feb 2021 12:52:51 GMT                                                                                                                   |
| ETag             | 资源标识符         | ETag: "56a88df57772gt555gr5469a32ee75d65dcwq989"                                                                                                         |
| Set-Cookie       | 服务端向客户端发送 | Cookie Set-Cookie: \_\_yjs_duid=1_7a24a73cae0e4926e7604ec1fd9277eb1614513171854; expires=Tue, 30-Mar-21 11:52:51 GMT; Path=/; Domain=baidu.com; HttpOnly |

### 什么是 HTTPS，与 HTTP 的区别？

（1）什么是 HTTPS？

HTTPS 的全称是 Hyper Text Transfer Protocol over SecureSocket Layer，基于安全套接字协议 SSL，提供传输加密和身份认证保证传输的安全性，通过证书确认网站的真实性

HTTP2.0 和 HTTP3.0 都只用于 https:// 网址

（2）HTTPS 三次握手
![https 三次握手](/images/https.png)
① Client Hello：客户端将支持 SSL 版本、加密算法、密钥交换算法等发送服务端

② Server Hello：服务端确定 SSL 版本、算法、会话 ID 发给客户端

③ Certificate：服务端将携带公钥的数字证书发给客户端

④ Server Hello Done：通知客户端版本和加密套件发完，准备交换密钥

⑤ Client Key Exchange：客户端验证证书合法性，随机生成 premaster secret 用公钥加密发给服务端

⑥ Change Cipher Spec：通知服务端后续报文采用协商好的密钥和加密套件

⑦ Finished：客户端用密钥和加密套件计算已交互消息的 Hash 值发给服务端。服务端进行同样计算，与收到的客户端消息解密比较，相同则协商成功

⑧ Change Cipher Spec：通知客户端后续报文采用协商好的密钥和加密套件

⑨ Finished：服务端用密钥和加密套件计算已交互消息的 Hash 值发给服务端。客户端进行同样计算，与收到的服务端消息解密比较，相同则协商成功

（3）HTTP 与 HTTPS 对比

| 项目       | HTTP           | HTTPS          |
| ---------- | -------------- | -------------- |
| 默认端口   | 80             | 443            |
| HTTP 版本  | 1.0 - 1.1      | 2 - 3          |
| 传输       | 明文，易被劫持 | 加密，不易劫持 |
| 浏览器标识 | 不安全         | 安全           |
| CA 认证    | 不支持         | 支持           |
| SEO        | 无优待         | 优先           |

### 对比 HTTP1.0 / HTTP1.1 / HTTP2.0 / HTTP3.0？

#### HTTP1.0

无状态，无连接的应用层协议

- 无法复用连接
  每次发送请求，都要新建连接
- 队头阻塞
  下个请求必须在上个请求响应到达后发送。如果上个请求响应丢失，则后面请求被阻塞

#### HTTP1.1

HTTP1.1 继承了 HTTP1.0 简单，克服了 HTTP1.0 性能上的问题

- 长连接
  新增 `Connection: keep-alive` 保持永久连接
- 管道化
  支持管道化请求，请求可以并行传输，但响应顺序应与请求顺序相同。实际场景中，浏览器采用建立多个 TCP 会话的方式，实现真正的并行，通过域名限制最大会话数量
- 缓存处理
  新增 `Cache-control`，支持强缓存和协商缓存
- 断点续传
  主机头
  新增 `Host` 字段，使得一个服务器创建多个站点

#### HTTP2.0

HTTP2.0 进一步改善了传输性能

- 二进制分帧

  在应用层和传输层间增加二进制分帧层

- 多路复用

  建立双向字节流，帧头部包含所属流 ID，帧可以乱序发送，数据流可设优先级和依赖。从而实现一个 TCP 会话上进行任意数量的 HTTP 请求，真正的并行传输

- 头部压缩

  压缩算法编码原来纯文本发送的请求头，通讯双方各自缓存一份头部元数据表，避免传输重复头

- 服务器推送

  服务端可主动向客户端推送资源，无需客户端请求

#### HTTP3.0

当一个 TCP 会丢包时，整个会话都要等待重传，后面数据都被阻塞。这是由于 TCP 本身的局限性导致的。HTTP3.0 基于 UDP 协议，解决 TCP 的局限性

- 0-RTT

  缓存当前会话上下文，下次恢复会话时，只需要将之前缓存传递给服务器，验证通过，即可传输数据

- 多路复用

  一个会话的多个流间不存在依赖，丢包只需要重发包，不需要重传整个连接

- 更好的移动端表现

  移动端 IP 经常变化，影响 TCP 传输，HTTP3.0 通过 ID 识别连接，只要 ID 不变，就能快速连接

- 加密认证的根文

  TCP 协议头没有加密和认证，HTTP3.0 的包中几乎所有报文都要经过认证，主体经过加密，有效防窃听，注入和篡改

- 向前纠错机制

  每个包还包含其他数据包的数据，少量丢包可通过其他包的冗余数据直接组装而无需重传。数据发送上限降低，但有效减少了丢包重传所需时间

### Cookie 和 Session 的区别？

| 项目       | Cookie                   | Session                                                                         |
| ---------- | ------------------------ | ------------------------------------------------------------------------------- |
| 存取值类型 | 字符串                   | 大多数类型                                                                      |
| 存取位置   | 客户端                   | 服务端，sessionId 非主动传参时，依赖 Cookie                                     |
| 存取方式   | 文件                     | 文件、内存、关系或非关系型数据库等                                              |
| 大小       | 受客户端限制             | 自行配置                                                                        |
| 过期时间   | 写入时设置，用户可清除   | 自行配置，用户可清除对应 Cookie，服务端自动清除过期 Session                     |
| 兼容性     | 需浏览器开启，用户同意   | 不依赖 Cookie 时，通过 Get 或自定请求字段传入                                   |
| 作用范围   | 可设置跨子域，不可跨主域 | 用户身份唯一标识符不变时，可跨域，跨服务器。默认受限于 Cookie，仅限会话期间有效 |

## 存储

### 什么是在线和离线事件 ？

navigator.online 被用来标识当前的网络状态， `true` 为连通， `false` 为离线

- 当 navigator.online 从 `false` 到 `true` ，触发 `online` 在线事件
- 当 navigator.online 从 `true` 到 `false` ，触发 `offline` 离线事件
  早期浏览器不同版本，对离线的标准实现存在差异，如有的浏览器存在脱机模式，被认为是在线状态，从 Firefox 41，IE 9，Chrome 14 和 Safari 5 起，绝大多数浏览器实现趋于一致，该状态和相应的事件都与真实网络状态相关

由于不同网站，域名解析，服务器及网关、应用防火墙等的存在，该属性及在线事件，不能表示用户可以访问某网站。实际的可访问性，仍然依赖发送到指定网站的请求来判断，对于跨域的情况，可以请求图片，CSS 或 JS，测试连通性。如果是插件，可以在 manifest.json 的 host_permissions 中添加需要跨域的网站主机头

```js
/** 在线事件 */
window.addEventListener('online', () => console.log('online'))
/** 离线事件 */
window.addEventListener('offline', () => console.log('offline'))
```

### 什么是 Service Worker？

- Web 应用程序、浏览器与网络之间的代理服务器
- 拦截网络请求，并根据网络采取适当动作，更新服务器资源
- 完全异步，不阻塞 JavaScript 线程，不能访问 DOM
- 提供入口以推送通知和访问后台同步 API
- 用于离线缓存，后台数据同步，响应来自其它源的资源请求，集中接收成本高的数据更新

### 什么是持久化存储 ？

持久化是将数据从瞬时状态转换为持久状态，通常是将内存中的数据模型转换为存储模型，根据持久化的作用域，持久化分为：

- 会话持久化：在网页会话或浏览器标签处于活动状态时，保留数据。
  - 例如：Session Storage API
    - 会话在浏览器打开期间保持，不受重新加载或恢复页面的影响
    - 在新标签或窗口打开页面时，会复制顶级浏览会话的上下文作为新会话的上下文
    - 打开多个相同 URL 的 Tabs 页面，创建各自 sessionStorage
    - 关闭浏览期窗口或标签，清除 sessionStorage
    - 缓存上限值一般为 5MB / 域名 左右
- 设备持久化：在跨会话、浏览器标签和窗口，在设备中保留数据
  - 例如：Cache API
    - Cache 接口以 URL 作为键名，将 Response 作为键值缓存
    - 缓存长期有效，需开发者手动设计清理逻辑
    - 缓存上限值按域名限制，浏览器自动管理，必要时，将全部删除某个域名下的缓存
- 全局持久化：跨会话、浏览器标签和窗口，跨设备，在云端保存设备
  - 例如：Web Extension Storage API 的 `storage.sync` 方法
    - 用户数据可以与浏览器账号自动同步
    - 即使使用隐身模式，用数据也可以保留
    - 异步读写
    - 存储对象，不需要转换为字符串

### 什么是 IndexedDB API ?

IndexDB 是事务型数据库系统，是基于 JavaScript 的面向对象数据库，通过索引实现对数据的高性能搜索。客户端处于离线状态，可以访问 IndexDB 存储的数据，其用于在客户端持久化存储大量的结构化数据，支持结构化克隆算法支持的类型：

- 原始类型（不含 Symbols ）
- Boolean 对象
- String 对象
- Date 对象
- RegExp 对象（不保留 lastIndex 字段）
- Blob 对象（二进制文件对象）
- File 对象
- FileList 对象
- ImageData 对象
- Array 对象
- ArrayBuffer 对象（通用、固定长度的二进制数据缓冲区）
- TypedArray 对象 （类型化数组）
- Object 对象 （包括对象字面量）
- Set 对象
- Map 对象

  不支持类型：

- Error 对象
- Funtion 对象
- DOM 节点
- 原型链上的属性和方法
  使用 IndexDB 创建数据仓库，添加索引，通过事务，增、删、查、改的代码示例：

```js
const datas = [
  { name: 'shon', phone: '13010001000' },
  { name: 'shon', phone: '13010001001' },
  { name: 'carl', phone: '13010001002' }
]
const request = indexedDB.open('leetcodeDB', 1) // 创建名为 leetcodeDB 数据库，版本号为 1
request.onerror = (e) => {
  // 数据库错误回调，底层如事务错误，也会冒泡到这里
  console.log(e.target.error) // 输出错误
}
request.onsuccess = (e) => {
  // 数据库打开 / 创建成功时回调
  const db = e.target.result // 保存数据库接口
  run(db)
}
request.onupgradeneeded = (e) => {
  // 数据库更新时回调
  const db = e.target.result // 保存数据库接口
  const store = db.createObjectStore('member', { keyPath: 'phone' }) // 创建会员仓库，使用手机号作为 keyPath （类似关系型数据库的主键）
  store.createIndex('name', 'name', { unique: false }) // 将名称作为非唯一索引
  store.transaction.oncomplete = () => run(db)
}
const run = (db) => {
  const transaction = db.transaction('member', 'readwrite')
  const memberStore = transaction.objectStore('member') /** 增 */
  datas.forEach((data) => memberStore.put(data)) // 将数据逐条插入数据仓库
  transaction.oncomplete = () => {
    const memberStore = db
      .transaction('member', 'readwrite')
      .objectStore('member') /** 删 */
    memberStore.delete('13010001001').onsuccess = () => {
      console.log('delete success')
    } /** 查 */
    memberStore.get('13010001000').onsuccess = (e) =>
      console.log(e.target.result.name) /** 改 */ // 输出：shon
    memberStore.get('13010001002').onsuccess = (e) => {
      e.target.result.name = 'shon' // 修改名称 carl -> shon
      memberStore.put(e.target.result).onsuccess = () => {
        /** 搜索 */
        const index = memberStore.index('name') // name 之前已经添加索引
        index.openCursor(IDBKeyRange.only('shon'), 'prev').onsuccess = (e) => {
          // 倒序搜索名称 shon
          const cursor = e.target.result
          if (cursor) {
            console.log(cursor.value.phone) // 依次输出手机号：13010001002 13010001000
            cursor.continue()
          }
        }
      }
    }
  }
}
```

输出如图：
![输出](/images/indexedDB.png)

### 什么是 Web Storage API ?

Web Storage API 是浏览器提供用来替代 Cookie 更直观，容量更大，更节省请求带宽的在客户端存取键值对类型数据的接口

#### Web Storage API 提供两种机制

- sessionStorage 存储区域根据域名隔离，该区域仅在页面会话期间可用。在浏览器实现了 WindowSessionStorage 对象挂载到 Window 对象的 sessionStorage 属性
- localStorage 存储区域根据根据域名隔离，除非用户操作，不会主动清空。在浏览器实现了 WindowLocalStorage 对象挂载到 Window 对象的 localStorage 属性

#### Web Storage API 提供的存储上限值：

- 现代浏览器一般是 5M 左右
- Firefox 45 起，浏览器崩溃或重启时，上限将限制为 10 M
- 手机 QQ、手机 QQ 浏览器、微信一般是 2M - 5M
- iOS 5.1 起，Safari 移动版将 localStorage 数据存储在缓存文件夹，空间不足时会偶尔清理

#### Web Storage API 提供 `1` 属性和 `5` 方法

- 属性
  `.length` 表示存储在 Storage 对象中的数据项的数量

- 方法
  - `.key(key)` 返回存储对象中第 key 项的键名，key 即索引，顺序由客户端实现
  - `.getItem(keyName)` 返回存储对象中键名为 keyName 对应的值
  - `.setItem(keyName, keyValue)` 创建或更新存储对象中键名为 keyName 的值为 keyValue
  - `.removeItem(keyName)` 从存储对象中删除键名为 keyName 的数据项，如果该键名不存在，则什么都不做
  - `.clear()` 清空存储对象中的所有键名及其对应的数据项

### 什么是 Cache API?

Cache API 以 URL 为键名，Response 为键值，为请求和响应提供缓存

- Cache API 可以在浏览器 window 下使用，也可以配合 Service worker 使用
- Cache API 存储的数据无法自动过期，开发者需要自行设计过期的逻辑
- Cache API 存储上限值按域名限制，浏览器自动管理，必要时将全部删除某个域名下的缓存
- Cache API 使用前，需要通过 CacheStorage API 返回 resolve 为 Cache 对象的 Promise
  - Caches.open(cacheName) 打开，若不存在则创建指定 `cacheName` 的 Cache，Cache 作为返回 Promise 的 resolve
  - Caches.has(cacheName) 检查指定 `cacheName` 的 Cache 是否存在，是否存在的布尔值作为返回 Promise 的 resolve
  - Caches.match(request, options) 在全局 Caches 按创建顺序查找第一个匹配 `request` URL 的 response 作为返回 Promise 的 resolve
  - Caches.delete(cacheName) 查找指定 `cacheName` 的 Cache
    - 找到，删除 Cache，返回 true 作为返回 Promise 的 resolve
    - 找不到，返回 false 作为返回 Promise 的 resolve
  - Cache.keys() 在全局 Caches 按创建顺序返回所有 Cache 对象的 CacheName 数组作为返回 Promise 的 resolve
- Cache API 提供的方法包括
  - Cache.match(request, options) 按添加顺序查找第一个匹配请求 `request` URL 的响应 `response` 作为返回 Promise 的 resolve
    - `options` 选项
      - ignoreSearch 是否忽略查询字符串，默认值 `false`
      - ignoreMethod 是否忽略方法 （GET / HEAD），默认值 `false`
      - ignoreVary 是否忽略 Vary 头，默认值 `false`
  - Cache.matchAll(request, options) 匹配请求 `request` URL 的响应 `response` 数组作为返回 Promise 的 resolve
    - `options` 选项
      - ignoreSearch 是否忽略查询字符串，默认值 `false`
      - ignoreMethod 是否忽略方法 （GET / HEAD），默认值 `false`
      - ignoreVary 是否忽略 Vary 头，默认值 `false`
  - Cache.add(request) 请求`request` URL，检查 `response.status`
    - 等于 200，以 URL 为键名，响应 `response` 为键值，添加到 Cache
    - 不等于 200 不添加
    - 无需等待响应体流式传输完成
    - 仅在 GET 请求可用
    - `undefined` 作为返回 Promise 的 resolve
  - Cache.addAll(requests) 请求 `requests` URL 数组，检查 `response.status`
    - 等于 200，以每个 URL 为键名，响应 `response` 为键值，添加到 Cache
    - 不等于 200 不添加
    - 无需等待响应体流式传输完成
    - 仅在 GET 请求可用
    - `undefined` 作为返回 Promise 的 resolve
  - Cache.put(request, response)
    - 以 `request` URL 为键名，指定 `response` 为键值，添加到 Cache
    - 可以不检查 `response.status`
    - 无需等待响应体流式传输完成
    - 仅在 GET 请求可用
    - `undefined` 作为返回 Promise 的 resolve
  - Cache.delete(request, { options })
    - 以 `request` URL 为键名，查找 Cache
      - 找到，删除，返回 `true` 作为返回 Promise 的 resolve
      - 找不到，返回`false` 作为返回 Promise 的 resolve
    - `options` 选项
      - ignoreSearch 是否忽略查询字符串，默认值 `false`
      - ignoreMethod 是否忽略方法 （GET / HEAD），默认值 `false`
      - ignoreVary 是否忽略 Vary 头，默认值 `false`
  - Cache.keys(request, options)
    - 以 `request` URL 为键名 或者 不传查找全部，查找 Cache
    - Cache 数组作为返回 Promise 的 resolve

### 对比 Cookie、LocalStorage、SessionStorage、Session、Toke

#### Cookie

- 保存位置：客户端
- 生命周期：expires 前有效，不设置 会话期间有效
- 存储大小：一般 4KB
- 数据类型：字符串
- 特点：
  - 请求头 cookie ，同域名每次请求都附加
  - 响应头 set-cookie 设置 cookie

#### LocalStorage

- 保存位置：客户端
- 生命周期：不清空缓存，一直有效
- 存储大小：一般 5MB
- 数据类型：字符串

#### SessionStorage

- 保存位置：客户端
- 生命周期：会话期间有效
- 存储大小：一般 5MB
- 数据类型：字符串

#### Seesion

- 保存位置：服务端，sessionid 存在 cookie 或 跟在 URL 后
- 生命周期：默认 20 分钟，可更改。清空 cookie 或 更改 URL 传参，影响 Session
- 存储大小：不限制
- 数据类型：字符串、对象、数组，序列化后以字符串存储

#### Token

- 保存位置：客户端 Cookie / WebStorage / 表单 等
- 生命周期：根据存储位置决定
- 存储大小：根据存储位置决定
- 数据类型：字符串
- 组成
  - uid 用户身份标识
  - time 时间戳
  - sign 签名
  - 其他参数

#### JWT - JSON Web Token

- 特点
  - 将部分用户信息存储本地，避免重复查询数据库
- 组成
- Header（头部）
  - alg 表示签名的算法，默认是 HMAC SHA256 (HS256)
  - typ 表示令牌的类型，JWT
- Payload（负载）
  - 7 个官方字段
    - jti 编号
    - iss 签发人
    - sub 主题
    - aud 受众
    - exp 过期时间
    - nbf 生效时间
    - iat 签发时间
  - 私有字段
    - name 姓名
    - admin 是否管理员
- Signature（签名）
  - secret 密钥
  - 使用指定 alg 签名算法，生成签名
    - HMAC SHA256(btoa(Header) + '.' + btoa(Payload), secret)
- 算出签名

## 性能

### JavaScript 垃圾回收机制

- 内存分配回收是自动的，垃圾回收器定时找出不再使用的数据，释放内存空间
- 两种回收检测模式
  - 引用计数：清除没有任何引用指向的数据。无法处理循环引用。IE6 使用
  - 标记清除：标记可达数据，清除不可达数据。可处理循环引用。现代浏览器广泛使用
    - 从根出发：包括 全局变量、本地函数的局部变量、参数、调用链上其它函数的局部变量和函数等
    - 标记相连的对象为可达和访问过
    - 直到引用链上没有未访问过的对象为止
    - 删除没有被标记过，即不可达对象
- 标记清除的优化：标记清除存在 内存不连续，回收效率低，偶尔卡顿 的缺点
  - 只在 CPU 空间时进行
  - 分代回收：
    - 新生代：存活时间短，新生或经过一次垃圾回收的对象
      - 复制：复制 From 的可达对象 到 To 空间，释放 不可达对象
        - 晋升：复制时，To 空间使用超过 25%，晋升到 老生代
      - 交换：交换 From 和 To 空间
    - 老生代：存活时间长，经过一次被晋升或多次垃圾回收的对象
      - 标记清除
      - 标记整理：清除阶段先整理，将可达对象连续放置一起，再释放之外的内存
      - 增量标记：用增量标记代替全暂停，在回收间歇执行应用逻辑，避免卡顿

### 详解标记整理算法

- 标记完成
- 存活对象向内存空间一端移动
- 移动完成，清理掉边界外的所有内存

### 前端常见的内存溢出途径，如何避免？

占用内存且无法被垃圾回收机制回收对象，容易导致内存溢出（泄漏），让应用程序占用本应回收或不需要占用的内存

- 意外的全局变量：全局变量是标记清除中的「根」，除非定义为空 或 重新分配，不可回收

  - 非严格模式下，没有使用 var let const 声明的变量
  - 挂载在 this 下的属性

    **避免**：尽量不使用全局变量，在 JavaScript 头部使用严格模式

- 未清除的计时器

  - setInterval 自身及其回调函数内的对象，即使不被引用，也需要计时器停止才能清除

    **避免**：使用 requestAnimationFrame / setTimeout + 递归 代替 setInterval，并设置边界

- 删除不完全的对象

  - addEventListener 监听的对象已不可达，但监听没有移除。现代浏览器会自动移除
  - JS 中引用了 DOM 对象，对象已从 DOM Tree 中移除，但 JS 中依旧保持引用

    **避免**：

  - 移除对象前，移除监听。需大量监听对象，使用事件代理监听父元素
  - 移除 DOM 后，设置引用该 DOM 的变量为空

- 闭包中未使用函数引用了可从根访问的父级变量

```js
var global = 0
function closure() {
  let fromGlobal = global // 引用全局变量 global
  function unused() {
    // 闭包内不使用的函数
    if (fromGlobal) return // 引用父级变量 fromGlobal，导致 unused 占用内存
  }
  global = {} // 每次调用闭包 global 都会重新赋值
  /** 避免 **/
  fromGlobal = null
  closure()
}
```

### 如何诊断前端内存泄漏？

- 进入 Chrome 浏览器，打开要分析的网页和开发者工具
  - 切换到 Perfomance 面板
  - 勾选 Memory 选项
  - 点击圆圈录制按钮
  - 录制端一段时间，停止
  - 观察 JS Heap、Documents、Nodes、Listeners、GPU Memory 的数量是否有异常增长
- 发现异常增长，切换到 Memory 面板
  - 录制一个堆内存快照
  - 在页面上执行可能发生内存泄漏的操作
  - 再录制一个堆内存快照
  - 重复执行可能发生内存泄漏的操作
  - 最后录制一个堆内存快照
  - 选择最后一个堆内存快照，在右侧下拉菜单，选择 `Objects allocated between snapshots 1 and 2`
- 通过对比，找到新生成或者没有释放的对象，点击可以看到堆栈信息，并定位其所在代码的位置

## SEO

### 前端中有哪些 SEO 优化手段？

#### 文字

- 字号 14px 以上，16px 为宜，避免小于 12px，有行距、换行和段落
- 避免使用 visibility:hidden，display: none, 绝对定位，与背景相同颜色，堆砌关键词，隐藏主要内容

#### 图片

- Logo 的 DIV 中写关键词，设置 text-ident 为负数隐藏
- 图片添加 width 和 height，避免读取元数据，再重排
- 图片添加 alt，描述图片内容，便于搜索引擎蜘蛛理解，提升可访问性
- 主要图片与内容相关，不要过长或过窄，正方形为宜
- 主要图片设置 src 属性，避免全部图片都使用懒加载
- 图片可以点击放大，多张图片间可以切换

#### 适配

#### 独立 H5 网站

- H5 移动版与 PC 版域名不同，移动版子域名，推荐使用 m.x.com 等移动网站常用域名
- 向搜索引擎提交适配规则：PC 版和 H5 移动版组成一一对应的 URL 对或正则匹配关系
- 不同域名，使用不同蜘蛛抓取

#### 代码适配

- H5 移动版和 PC 版域名相同，返回代码不同
- 后端根据 User-Agent，返回不同的代码
- 添加响应头：Vary: User-agent
- 同一 URL，蜘蛛应使用不同 UA 或不同蜘蛛多次抓取

#### 自适应

- H5 移动版和 PC 版 域名相同，返回代码相同
- 前端通过相对单位、媒体查询、srcset 实现响应式或自适应布局
- 同一 URL，蜘蛛可以只抓取一次

#### SSR：Server Side Render 服务端渲染

## 安全

### 什么是帆布指纹？

**目标**：追踪用户

**背景**：移动互联网 IP 经常变化，用户禁用 cookie

**解决**：

**Canvas Fingerprinting**

- 不通过 cookie
- 用户不易屏蔽
  **手写代码**

```js
const canvas = document.createElement('canvas')
const ctx = canvas.getContext('2d')
const txt = 'canvasfingerprinting'
ctx.fillText(txt, 0, 0)
const b64 = canvas.toDataURL().replace('data:image/png;base64,', '') // 返回一个包含图片的 data URI，并替换 Mine-type，返回 base64 编码
const bin = atob(b64) // 函数能够解码 base64 编码的字符串数据
const canvasFingerprinting = bin2hex(bin.slice(-16, -12)) // 将 Unicode 编码转为十六进制
```

**fingerprintJS2 / fingerprintJS**

除 canvas 外，加入其它影响因素：

- navigator.userAgent 用户代理
- navigator.language 用户语言
- screen.colorDepth 屏幕色彩信息
- screen.height / screen.width 屏幕宽度和高度
- Date().getTimezoneOffset() 格林威治时间与本地时间时差
- seesionStorage 是否支持 sessionStorage
- localStorage 是否支持 localStorage
- indexedDB 是否支持 indexedDB
- addBehavior 是否支持 document.body.addBehavior IE5 属性
- openDatabase 是否支持调用本地数据库
- cpuClass 浏览器所在系统的 CPU 等级
- navigator.platform 客户端操作系统
- doNotTrack 是否支持 Do not track 功能
- Flash plugin / Adobe PDF reader / QuickTime / Real players / ShockWave player / Windows media player / Silverlight / Skype

### 对比各种分布式 ID 的生成方式？

#### UUID

- 生成简单，本地生成
- 无序，无意义

#### 数据库自增 ID

- `auto_increment` 实现简单，单调自增，查询快
- 数据库服务器宕机风险
  - 使用 SELECTLAST_INSERT_ID() 代替 `max(id)` 提高高并发时的查询效率
  - 不同数据库服务器，设置不同自增起始值和步长

#### 数据库自增 ID 段

```sql
CREATE TABLE ids_increment (
  type int(8) NOT NULL COMMENT '业务类型',
  max_id int(8) NOT NULL COMMENT '当前业务的最大ID',
  step int(8) NOT NULL COMMENT '当前业务的ID段步长',
  version ini(8) NOT NULL COMMENT '当前业务的版本号，每次分配 +1，乐观锁'
)
```

#### Redis

- `set` 字段的初始值 `incr` 该字段，每次 `+1`
- 使用 `RDB` 定时持久化
- 使用 `AOF` 命令持久化

#### 雪花算法

- 64 位 ID：符号位（1 位） + 时间戳（41 位） + 机器 ID（5 位） + 数据中心 ID（5 位）+ 自增值（12 位）

### 列举各种跨域方法

#### （1）跨域

协议、域名、端口不同，需要跨域

#### （2）跨域解决方案

**jsonp：JSON with Padding**

- `<script>` 标签没有同域限制
- 服务端返回页面上 callback 包裹的 json 数据
- 兼容性好
- 仅支持 GET

**CORS：Cross-origin resource sharing 跨域资源共享**

**请求类型：**

**简单请求 ：**

满足以下 2 条件

- GET HEAD POST
- Content-Type
  - application/x-www-form-urlencoded
  - multipart/form-data
  - text/plain

**复杂请求：**

不满足以上 2 条件

- 需发送 OPTION 预检请求，查询服务器支持的方法

**按请求类别处理**

```js
const express = require('express')
const app = express()
const whiteList = ['http://localhost']
app.use((req, res, next) => {
  const origin = req.headers.origin
  if (whiteList.includes(origin)) {
    // 允许访问源，附带凭证请求时，必须指定 URI。相反，可设置为 *
    res.setHeader('Access-Control-Allow-Origin', origin)
    // 允许请求头，逗号隔开
    res.setHeader('Access-Control-Allow-Headers', 'authorization, username')
    // 允许请求方法，逗号隔开
    res.setHeader('Access-Control-Allow-Methods'， 'GET, HEAD, POST, OPTIONS')
    /* 允许凭证
       客户端需配置 const xhr = new XMLHttpRequest()
       xhr.withCredentials = true */
    res.setHeader('Access-Control-Allow-Credentials', true)
    // 预检请求的返回结果，允许请求头和请求方法可以被缓存多久，缓存期间不再发送预检请求，单位秒
    res.setHeader('Access-Control-Allow-Max-Age', 10)
    // 允许响应头
    res.setHeader('Access-Control-Expose-Headers', 'authorization, username')
    if (req.method === 'OPTIONS') {
      res.end() // 预检请求直接返回空响应体
    }
  }
})
```

**postMessage**

- window 属性
- 跨窗口，跨框架`frame`、`iframe`，跨域
- 允许不同源脚本采用异步方式进行有限通信

```js
otherWindow.postMessage(message, targetOrigin, [transfer])
// otherWindow:
iframe.contentWindow 属性
window.open 返回
window.frames 访问
window.onmessage = e => console.log(e.data) // 接收返回数据
```

**Websocket**

- 基于 TCP
- 全双工通信
- 应用层协议

```js
// 客户端
const socket = new WebSocket('ws://localhost:3000')
socket.onopen = () => socket.send('message') // 向服务器发送数据
soket.onmessage = (e) => console.log(e.data) // 接收服务器返回数据
// server.js
const express = require('express')
const app = express()
const ws = require('ws')
const wss = new ws.Server({ port: 3000 })
wss.on('connection', (ws) => {
  ws.on('message', (data) => console.log(data))
})
```

**代理服务器转发**

- 代理服务器设置 CORS 请求头字段
  - nginx
    - add_header
  - kangle
    - 回应控制，增加表，标记模块，add_header
  - nodejs
    - response.writeHead
- 代理服务器向源服务器继续请求
  - nginx
    - 七层 HTTP 代理：配置 http
    ```
    http {
      server {
        listen 80;
        location / {
          proxy_pass http://127.0.0.1:3000
        }
      }
    }
    ```
    - 四层 TCP 代理：配置 stream
    ```
    steam {
      upstream proxyServer {
        server 127.0.0.1:3000;
      }
      server {
        listen 80;
        proxy_pass proxyServer;
      }
    }
    ```
  - kangle
    - 七层 HTTP 代理
      - 请求控制，增加表
      - 目标设置为代理
      - 匹配模块设置原域名和端口，标记模块设置目标域名和端口
  - nodejs
    - 七层 HTTP 代理
    ```js
    const http = require('http')
    http.request({
      host: '127.0.0.1',
      port: 3000,
      url: '/'
    })
    ```

**document.domain**

- 主域名相同，子域名不同
- 设置值为 主域名
  **iframe**
- window.name
  - 不超过 2MB
  - 同一个 iframe
    - 加载跨域页，跨域页设置 window.name
    - 加载同域页，读取 iframe.contentWindow.name
- location.hash
  - 不会被 URL 编码
  - 加载跨域页，参数跟在 `#` 后。window.onhashchange 监听 hash 变化
  - 跨域页获取 location.hash，加载同域页，参数跟在 `#` 后
  - 同域页设置 window.parent.parent.location.hash = location.hash，将参数回传

### 什么是点击劫持，如何防御 ？

点击劫持，通常会使用透明的 `<iframe> `元素链接被攻击网站，并将其覆盖在恶意页面之上，诱导用户点击恶意页面上某个元素，而实际点击的是被攻击网站的某个元素。引导用户在不知情的情况下，与被攻击网站发生交互，劫持用户的点击、Cookie、以及自动填充的密码或拖拽的文件等

防御点击劫持的核心是禁止页面被嵌套，或禁止页面在嵌套时被点击、响应拖拽，共享 Cookie

- 禁止页面被嵌套

  - 使用 JavaScript

  ```js
  if (top != window) top.location = window.location
  ```

  - 原理：当页面被嵌套时，自动跳转到当前页面
  - 局限性（以下场景失效，下同）：
    - 禁用 JavaScript
    - 在恶意页面监听 `onbeforeunload` 事件，当用户点击否，停止退出
    - 设置 `iframe` 的 `sandbox` 属性，将 iframe 沙箱化，不添加 `allow-top-navigation` 禁止其更改 `top.location` , IE 10 + 兼容

- X-Frame-Options
  - 原理：禁止页面被嵌套，或者设置页面可被嵌套的策略
  - 局限性：
    - 老版本浏览器不兼容
    - 善意第三方将无法嵌套网页
- 设置 Cookie 的 `SameSite` 属性
  - 原理：`iframe` 嵌入被攻击网页，Cookie 不会被发送
    - 值为 `Lax` 时，当前网页的 top.location.href 与请求 URL 不同域时，除链接、预加载请求、GET 表单外，不发送 Cookie
    - 值为 `Strict` 时，当前网页的 top.location.href 与请求 URL 不同域时，始终不发送 Cookie
  - 局限性：
    - 老版本浏览器不兼容
    - Chrome 84 / Firefox 69 起的默认 `SameSite=Lax`，Chrome 较宽松，因为其允许在顶级 POST 请求上发送某些 Cookie
- 拦截点击
  - 原理：使用一个透明层，在 `top != window` 时，覆盖整个网页，拦截点击
  - 局限性：
    - 禁用 JavaScript
    - 影响 SEO，可能会被认为故意遮主体内容，作弊
    - 善意嵌套也会触发拦截

### 如何提高 iframe 嵌入内容的安全性 ？

- 采取防止点击劫持措施
  - 声明 `X-Frame-Options` 的属性：`deny` `sameorigin` `allow-from` 来源
  - 当页面被嵌套时，弹出透明的层覆盖文档，阻止用户与文档上的元素交互
  - 设置 Cookie 的 `SameSite` 属性，页面被嵌套时无法读取直接打开时的 Cookie
- 使用 HTTPS
  - HTTPS 由 HTTP + SSL 协议构建，可进行加密传输、身份认证，比 HTTP 安全性高
  - 现代浏览器安全策略限制 HTTPS 下不能使用 `<iframe>` 嵌入 HTTP 内容
  - HTTP 与 HTTPS 因协议不同，受同源策略限制
    - 互相嵌套时，HTTP 不能访问 HTTPS 内容，反之亦然
    - HTTPS 在 CA 机构签发证书时，需要验证域名所有权，伪造 HTTPS 同域几乎不可能
- 设置 `sandbox` 属性，使用沙箱运行 `<iframe>`
  - 默认不设置具体值，即开启所有限制
  - 每一项限制用半角空格分隔
    - `allow-downloads-without-user-activation` 用户未激活时可以启动下载
    - `allow-forms` 允许提交表单
    - `allow-modals` 允许模态框
    - `allow-orientation-lock` 允许方向锁定
    - `allow-pointer-lock` 允许嵌入内容使用 Pointer Lock API 锁定指针
    - `allow-popups` 允许 `window.open` 弹窗
    - `allow-popups-to-escape-sandbox` 允许弹窗不受沙箱限制
    - `allow-presentation` 允许嵌入内容使用 Presentation API
    - `allow-same-origin` 不打开该项限制，所有加载网页视为跨域
    - `allow-scripts` 允许嵌入内容允许非弹窗外的脚本，与 `allow-same-origin` 一起使用，存在安全风险，即嵌入网页可能可以设置或删除 `sandbox` 属性
    - `allow-storage-access-by-user-activation` 用户激活时嵌入内容可通过 Storage Access API 访问父窗口的 Storage
    - `allow-top-navigation` 允许嵌入内容修改父窗口 `top.location`
    - `allow-top-navigation-by-user-activation` 用户激活时，允许嵌入内容修改父窗口 `top.location`
- 配置 CSP 内容安全策略
  - 策略 `policy` 可以配置在响应头 `Content-Security-Policy`
  - 策略 `policy` 可以配置在 `meta` 标签 `http-equiv="Content-Security-Policy"`
  - 策略类型
    - `default-src` 默认策略，没有配置后面的策略时，采用的策略，必须
    - `img-src` 图片策略
    - `media-src` 多媒体策略
    - `script-src` 脚本策略
    - `style-src` 样式策略
    - `font-src` 字体策略
    - `object-src` 插件策略
    - `child-src` 框架
    - `connect-src` HTTP 连接策略
    - `workder-src` Worker 脚本策略
    - `manifest-src` Manifest 策略
    - `prefetch-src` 预加载或预渲染策略
  - 策略值
    - `self` 同源策略，关键字，用引号包裹
    - `none` 禁止加载任何外部资源，关键字，用引号包裹
    - 域名，泛域名（支持 `*` 通配符），网址（含协议头 `http://` 或 `https://` )，路径名，协议名
    - `report-uri` + 网址，向指定 URL 发送违例报告
      - 调试时，可以将策略 policy 配置到 `Content-Security-Policy-Report-Only` 响应头，只报告不应用策略
    - `script-src` 关键字，用引号包裹
      - `unsafe-inline` 允许 `<script>` 标签和事件监听函数
      - `unsafe-eval` 允许将字符串作代码执行，包含使用 `eval` `Function` `setTimeout` `setInterval` 函数
      - `nonce-{token}` 允许 `<script nonce={token}></script>` 中代码执行
      - `{hash}` 允许 `<script>` 中的 `{hash}` 值相符的代码执行

### 什么是插件，为什么要使用 Web 技术代替插件 ？

（1）什么是插件？

插件，英文名为 plugin-in、plugin、add-in、addin、add-on、addon、extension。

插件是一种应用程序，通过应用程序自身与用户交互，为应用程序增加所需要的特定功能，减少应用程序自身的体积。

插件运行依赖于应用程序提供服务、接口，必须加载到应用程序或网络传输协议中，与应用程序交换数据。

应用程序本身不依赖于插件，可以独立运行，插件一般不会更改应用程序自身。

区别于插件，拓展不必通过应用程序自身与用户交互，可以有自己的独立界面。

（2）对于不同应用场景，插件有不同的具体含义

- 对于 Web 浏览器来说，插件是能够为浏览器自身无法读取的内容提供访问权限的软件，例如 Flash、PDF 等
- 对于电子邮件客户端，插件是用来加密和解密的软件
- 对于绘图软件，插件是用来支持不同文件格式、处理图片、支持自动化批量的软件
- 对于媒体播放器，插件是用来支持不同媒体格式的软件、提供视觉、音效等增强
- 对于集成开发环境，插件用来支持不同编程语言、提供文件系统、语法高亮、拼写检查、版本管理、终端等增强
  （3）为什么要使用 Web 技术代替插件？

- 传统插件因安全隐患、移动端兼容、耗电、内存泄漏问题不再被支持

  - ActiveX：曾被 Microsoft 在 Windows 内置，被恶意网站利用安装病毒或后门，例如
    - Scripting.FileSystemObject 可操作新增或修改文件内容
    - WbemScripting.SWbemLocator 可操作 WMI 访问登录信息
    - WScript.Shell 可从浏览器之中直接运行外部可执行文件
    - Microsoft 在 2015 年 7 月 29 日发行 Windows 10，以不支持 ActiveX 的 Microsoft Edege 浏览器作为默认浏览器，作为可选浏览器的 Internet Explorer 11 于 2022 年 6 月 15 日退役
  - Flash：Adobe 在 2020 年 12 月 31 日之后不再支持 Flash Player，并且从 2021 年 1 月 12 日开始阻止 Flash 内容在 Flash Player 中运行，因此 Adobe 强烈建议所有用户立即卸载 Flash Player 以帮助保护他们的系统

- 信息平等、增强可访问性、利于搜索引擎收录

  - 通过插件提供访问权限的内容，需要用户安装插件，由于系统、配置、平台和地区等差异，用户能否平等访问信息，受到能否安装，运行插件的限制
  - 传统插件通过 `<embed>` `<object>` 等嵌入浏览器，其内容不经特殊处理，无法在源代码中体现，这意味着依赖文档结构的读屏软件、搜索引擎蜘蛛无法读取这部分内容，从而无法正确地这部分内容建立索引，计算权重。这部分内容对于无法阅读或搜索引擎用户就像黑盒一样不可见
  - Flash: 可以通过为图形元素提供替代文本，允许用户按顺序阅读、键盘控制、提供字幕、控制音频播放、为导航添加说明、避免仅使用颜色区分不同信息等方式来增强可访问性，但不使用 Flash，或者使用 Adobe Animate CC 等按上述原则构建等效 HTML5 方案是更好选择

- HTML 5、CSS 3+ 模块化标准和 ES 6+

- Microsoft Edge、Mozilla Firefox、Google Chrome、Apple Safari、Opera 等都支持 HTML5、CSS 3+ 模块化标准和 ES 6+
- 现代浏览器的广泛普及以及自动更新的特性，允许开发者使用 Web 技术支持以前需要使用插件开发的功能
- 需要更多本地权限或跨域，可以用 Web 技术实现的扩展或附加组件的形式提供给 Chrome 或 Firefox 等现代浏览器

### 什么是内容安全策略（CSP）？

什么是内容安全策略（CSP）？
（1）什么是内容安全策略（CSP）？

内容安全策略（Content Security Policy）是用于检测并削弱某些特定类型攻击的额外安全层

- 预防跨站脚本攻击（XSS - Cross Site Scripting）
  - 通过 CSP 设置信任的可执行脚本的来源
    - 可设置白名单 URL，域名，仅加载 https
    - 通过 token 或 hash 限制内联脚本等
- 预防数据包嗅探、中间人攻击和 HTTP 劫持
  - 通过 CSP 设置信任的资源的来源，必须使用 https 协议
    - HTTP 超文本传输协议位于 OSI 模型的第 7 层，传输以纯文本形式进行
    - HTTP 数据包可以被嗅探，容易遭受中间人攻击
    - HTTPS 流量经过加密
      - 即使嗅探到数据包或者以其他方式截取数据包
      - 它们也会呈现为无意义的字符
- 数据注入攻击
  - 通过 CSP 设置信任的资源的来源 - 当数据注入发生后，阻止浏览器加载非法来源的数据
    （2）如何配置内容安全策略（CSP）？
- 策略 `policy` 可以配置在响应头 `Content-Security-Policy`
- 策略 `policy` 可以配置在 `meta` 标签 `http-equiv="Content-Security-Policy"`
- 策略类型
  - `default-src` 默认策略，没有配置后面的策略时，采用的策略，必须
  - `img-src` 图片策略
  - `media-src` 多媒体策略
  - `script-src` 脚本策略
  - `style-src` 样式策略
  - `font-src` 字体策略
  - `object-src` 插件策略
  - `child-src` 框架
  - `connect-src` HTTP 连接策略
  - `workder-src` Worker 脚本策略
  - `manifest-src` Manifest 策略
  - `prefetch-src` 预加载或预渲染策略
- 策略值

  - `self` 同源策略，关键字，用引号包裹
  - `none` 禁止加载任何外部资源，关键字，用引号包裹
  - 域名，泛域名（支持 \* 通配符），网址（含协议头 `http://` 或 `https://` )，路径名，协议名
  - `report-uri` + 网址，向指定 URL 发送违例报告
    - 调试时，可以将策略 `policy` 配置到 `Content-Security-Policy-Report-Only` 响应头，只报告不应用策略
  - `script-src` 关键字，用引号包裹
    - `nsafe-inline` 允许 `<script>` 标签和事件监听函数
    - `unsafe-eval` 允许将字符串作代码执行，包含使用 `eval` `Function` `setTimeout` `setInterval` 函数
    - `nonce-{token}` 允许 `<script nonce={token}></script>` 中代码执行
  - `{hash}` 允许 `<script>` 中的 `{hash}` 值相符的代码执行

### 什么是 XSS ，如何防范 XSS ？

（1）定义

通过 Web 开发留下的漏洞注入恶意代码，使用户加载并执行攻击者恶意制造的程序，与 Web 开发相关的 JavaScript，Java，VBScript，ActiveX，Flash 或 HTML 都可能被注入

攻击成功后，攻击者将得到更高权限、私密网页内容、会话和 Cookie

（2）分类

- DOM-based 型

  - 范围：客户端
  - 攻击方式

  文档对象模型（DOM）是 HTML 和 XML 文档的编程接口，它提供了对文档的结构化表述，并定义了一种方式，可以在程序中访问并操作该结构，从而改变文档结构，样式和内容
  设置属性或内容来自 Location 或 Document 接口或 Socket 接口等其它客户端传递 Message 的途径，未经过滤和转义，包含 JavaScript 脚本的恶意代码通过 URL 或 Referer 传入，被意外执行，轻则影响用户体验，客户端崩溃，重则用户数据被发送，身份被冒充用于滥发消息、投票、转账等进而引发社会工程学相关安全问题

  - 传递路径

  Location 或 Document 接口 或 Socket 接口等其它客户端传递 Message 的途径 → 客户端

  - 传播方式

  构造特殊 URL 或从特定或伪造来源发起请求，诱导用户访问或点击，一次性攻击

- 反射型 / 非持久型

  - 范围：客户端 + 服务端

  - 定义

  设置属性或内容来自后端，未经过滤和转义，包含 JavaScript 脚本的恶意代码通过 URL 或 Referer 传入，被意外执行，轻则影响用户体验，客户端崩溃，重则用户数据被发送，身份被冒充用于滥发消息、投票、转账等进而引发社会工程学相关安全问题

  - 传递路径

  Location 或 Document 接口 或 Socket 接口等其它客户端传递 Message 的途径 → 服务端 → 客户端

  - 备注

  与 DOM-based 的区别在于不需要服务端参与，服务端将恶意内容反射回客户端，即反射型攻击的命名来源

  - 传播方式

  构造特殊 URL 或从特定或伪造来源发起请求，诱导用户访问或点击，一次性攻击

- 存储型 / 持久型

  - 范围：客户端 + 服务端

  - 攻击方式

  设置属性或内容来自数据库或 Web 或 Extension 存储或 Cookie 中，未经过滤和转义，包含 JavaScript 脚本的恶意代码通过 URL 或 Referer 以及用户主动提交等方式传入，并被存入数据库或 Web 或 Extension 存储或 Cookie 中，读取后，被意外执行，轻则影响用户体验，客户端崩溃，重则用户数据被发送，身份被冒充用于滥发消息、投票、转账等进而引发社会工程学相关安全问题

  - 传递路径

  Location 或 Document 接口 或 Socket 接口等其它客户端传递 Message 的途径和用户主动提交 → 服务端 → 数据库 → 客户端 → 客户端

  Location 或 Document 接口 或 Socket 接口等其它客户端传递 Message 的途径和用户主动提交 → Web 或 Extension 存储或 Cookie → 客户端

  - 传播方式

  寻找过滤和转义缺乏或不完善的提交及展示路径，将恶意 JavaScript 脚本代码经过处理，提交到存储引擎，攻击者通过读取存储引擎的展示路径，持久攻击

（3） 防御

① 限制输入（来源）

- 前端和后端同时校验数据长度、类型、格式是否符合预期
- 始终过滤嵌入内容，如 `iframe` `object` `embed` ，推荐始终过滤可执行代码，如 `<script>` `，css` 中 `expression` 表达式和 `behavior` 属性，
- 建立黑白名单，过滤不需要的标签，属性，内容或者只保留符合预期的相应项目
- 在代理端、 服务器端、CDN 边缘节点、Web 服务器端、后台脚本端建立并维护 WAF 规则库或者购买相应安全防护服务，拦截以下请求：
  - 请求行：请求头，请求体包含敏感、恶意、垃圾内容
  - 请求来源：如 IP，用户代理，地区，代理 IP，Origin，Referer，Cookie，帆布指纹等来源标识无法相互印证，被伪造，已被标记为高风险或命中黑名单
  - 请求行为：如请求频率过高，短期大量请求敏感路径和参数，停留时间、请求总数、请求历史记录不符合真实用户，频繁索取权限，读取敏感数据，一次性 token 被重复使用，不回应验证码，验证问答，或多次验证失败
- 转义所有 UGC（用户生成内容），例如将 HTML 中预留字符转为字符实体

② 限制输出（渲染）

- 始终避免将输入内容作为 HTML 渲染

  - 避免使用 `.innerHTML` `.outerHTML` 和 `document.write()` `document.writeln()`
  - ```js:no-v-pre
    避免在模板渲染引擎支持的模板中使用 {{{}}}标签
    ```
  - 避免在框架，如 React 中使用 `dangerouslySetInnerHTML={ {__html:''}}` 和 Vue 中使用 `v-html` 等
  - 避免使用内联方式，添加事件监听属性，推荐使用`addEventListener()`
  - 推荐使用 `.innerText` 或 `.textContent` 设置内容，属性直接操作 DOM 属性节点

- 根据输入内容的渲染位置作相应限制
  - HTML 解析环境
    - 范围：HTML 标签、 HTML 属性
    - 限制：将 HTML 中预留字符转为字符实体
  - JavaScript 解析环境：
    - 范围：Script 标签、事件属性
    - 限制：将 `\` 添加额外 `\` 的转义，除字母及数字之外， `charCode` 小于及等于 127 的字符使用 `\x` + 16 进制编码，大于 127 使用 Unicode 编码
  - URL 解析环境
    - 范围：`href` 属性、 `src` 属性、 `srcset` 属性
    - 限制：使用 `encodeURI` 转义非 URL 保留字符，Mark 字符和大小写字母、数字以外字符
  - 避免执行远程代码
    - 避免在 Web 端使用 `eval()` 和 `new Function()` 执行远程代码
    - 避免在 Extension 端使用 `chrome.tabs.executeScript({code: '...'})` 和 `chrome.scripting.executeScript({code: '...'})` 执行远程代码
    - 推荐将所有远程代码（JS / Webassembly / CSS） 下载到本地使用
  - 使用黑白名单渲染 - 根据上下文，只渲染需要的标签和属性，过滤危险标签和属性，转义需要但存在风险的标签和属性。例如，前后端都是 JavaScript 可以通过 `js-xss` 库实现
    ③ 鉴权
- 限制 Cookie 访问
  - 设置 `Secure` 属性，声明 Cookie 只能通过 HTTPS 协议传输，依然有可能通过访问客户端硬盘读取
  - 设置 `HttpOnly` 属性，声明 Cookie 只对服务端会话可用，无法通过`Document.cookie` 访问，有助于缓解依赖此接口的 XSS 的攻击
  - 设置 `SameSite` 属性
    - 值为 `Lax` 时，当前网页的 top.location.href 与请求 URL 不同域时，除链接、预加载请求、GET 表单外，不发送 Cookie
    - 值为 `Strict` 时，当前网页的 top.location.href 与请求 URL 不同域时，始终不发送 Cookie
  - 使用预防点击劫持的方法，禁止网页被嵌入，或者嵌入时弹出空白层禁止用户操作
- 配置 CSP 内容安全策略
  - 配置 `style-src` `script-src` `img-src` `connect-src` `workder-src` `manifest-src` 等的 `self` 策略，只允许加载同源文件，与同域 URL 通信
  - 配置 `script-src`
    - 避免使用 `unsafe-inline` 允许内联 `<script>` 和事件监听函数
    - 避免使用 `unsafe-eval` 允许使用 eval Function setTimeout setInterval 函数
    - 推荐使用 `nonce-{token}` 和 `{hash}` 策略，只允许 `token` 或 `hash` 一致的 `<script>` 标签执行
- 与预防 CSRF 的防御中的方法组合使用，避免 XSS + CSRF 扩大攻击
  - 校验 `Referer`
  - 校验 `token`
    - 前端生成令牌：混淆前端计算 `token` 的代码。计算算法容易被破解
    - 令牌同步模式：将 `token` 计算放入后端，前端只读取 `token` 值。容易被盗用
    - 令牌同步模式增强：将 `token` 计算放入后端，并绑定用户唯一标识符及使用环境。前端只读取 `token` 值，该 `token` 只能由绑定用户在指定环境中使用，一次性或自动过期。依然有破解的可能，容易误伤正常用户
  - 验证码、验证问答、验证语音、验证图片、生物识别等
    - `token` 校验的必要补充，在 `token` 校验失败时，避免影响用户，要求其验证
      - 一般操作，验证通过，在一定时间，一定次数内，不再重复验证
      - 敏感数据，风险操作，一个请求，一次验证
- ④ 业务侧
- 开发者
  - 建立网址安全云库或使用第三方的 API，禁止用户访问仿冒、钓鱼、恶意网站，对未知安全的网址提示用户不要输入敏感信息
  - 建立内容安全监控平台，深度学习大数据，定义参数，预测热门内容传播模型。对不符合传播规律，短期内异常传播的内容进行二次审查，减少 XSS 蠕虫、钓鱼的内容传播
- 用户
  - 推荐用户使用支持沙箱运行的现代浏览器，严格限制恶意脚本能够访问的内容，缩小被攻击时影响范围
  - 推荐用户使用带有 XSS Filter 的浏览器，如 Google Chrome
  - 推荐用户安装防病毒软件或者启用浏览器的安全功能，拦截仿冒、钓鱼、恶意网站

### 什么是 CSRF ，如何防范 CSRF ？

（1）定义：

CSRF，跨站请求伪造，英文全称为 Cross-site request forgery

盗用用户身份的唯一标识符，冒充用户，伪造来源，模拟用户行为，执行未经其授权的的操作

（2）分类：

- 基于 Cookie 的 CSRF

  - 通过 XSS 漏洞，在要攻击页面，注入 Script 脚本，通过 `document.cookie` 获取用户 Cookie，通过设置可有限跨域标签的属性，如 `<img>` 的 src 属性，或 `<iframe>` 的 src 属性， 或`<link>` 的 href 属性等，以及通过 `<embed>` `<object>` 的 src 属性和引入插件自身的漏洞，将 Cookie 发送给第三方网站
  - 通过 XSS 漏洞，在要攻击页面，注入 Script 脚本，同域下通过 `XHR` `Fetch` 或上述设置标签属性的方式，发起恶意请求
  - 通过 XSS 漏洞，在要攻击页面所在域的其它存在漏洞的页面，注入 Script 脚本，通过 `<iframe>` 嵌入要攻击页面，通过 `contentDocument.cookie` 获取 Cookie，通过可有限跨域标签的属性、插件属性或漏洞，将 Cookie 发送给第三方

- 基于 Token 的 CSRF

  - Token 由前端生成：尝试使用第三方工具或者浏览器的控制台还原混淆后的代码。使用 Tampermonkey 或自行开发 Extension，注入 Script，恢复控制台的使用，清除或覆盖随机注入 Debugger 等其它干扰代码调试的定时器和 Observer。最终还原 Token 生成算法
  - Token 由后端生成：
    - 抓取网页源代码，使用正则或 DOM 解析（如 JSDOM 或 cheerio）方式获取 Token
    - 使用无头浏览器，如 PhantomJS 或 Headless Chrome 等模拟用户访问获取 Token
    - 使用 Webview 嵌入 Token 所在网页，通过 Webview API 获取 Token

- 基于帆布指纹的 CSRF

  - 对抗 Canvas 指纹
    - 重写 `HTMLCanvasElement.prototype` 的方法，伪造用户的 Canvas 指纹
  - 对抗浏览器指纹
    - 使用虚拟机 + 浏览器，仿造用户环境
    - 自行编译浏览器或使用候鸟浏览器等，伪造关键特征，如用户代理，系统、分辨率，WebRTC 指纹等

- 基于用户行为的 CSRF
  - 使用无头浏览器或 Webview，在客户端隐藏打开网页，模拟用户行为发起请求
  - 使用模拟器或按键精灵等软件，录制或开发脚本，在客户端模拟用户行为发起请求

（3）防御

- 基于 Cookie 的防御

  - Cookie 设置 `Secure` 属性，声明允许 Cookie 通过 https 传输
  - Cookie 设置 `HttpOnly` 属性，声明 JavaScript 无法访问 Cookie
  - Cookie 设置 `SameSite` 属性
    - 值为 `Lax` 时，当前网页的 top.location.href 与请求 URL 不同域时，除链接、预加载请求、GET 表单外，不发送 Cookie
    - 值为 `Strict` 时，当前网页的 top.location.href 与请求 URL 不同域时，始终不发送 Cookie
  - 替代 Cookie
    - 使用 Storage API 替代村存储原来需要 Cookie 存储到客户端的数据
    - 使用 token 替代 Cookie 作身份验证

- 基于来源的防御

  来源可以被伪造，且不同浏览器的实现存在差异，部分真实用户请求来源也被修改，容易误伤，故不推荐

  - 校验 Origin

    如果 Origin 不为空，判断 Origin 是否合法

    - IE 11 跨站请求，Origin 为空
    - 302 重定向请求，Origin 为空
    - 使用 Curl 或在非浏览器环境或特殊浏览器，自定义 HTTP 头，可伪造 Origin
    - 用户的 HTTP 请求被网关或代理修改，可伪造 Origin

  - 校验 Referer

    如果 Referer 不为空，判断 Referer 是否合法

    - IE 6/7 使用 `window.location.href` 或 `window.open` 跳转或打开 URL，Referer 为空
    - HTTPS 到 HTTP， Referer 为空
    - 插件跳转到网页，Referer 不确定
    - 使用 Curl 或在非浏览器环境或特殊浏览器，自定义 HTTP 头，可伪造 Referer
    - 用户的 HTTP 请求被网关或代理修改，可伪造 Referer
    - 用户出于正常需求，直接打开请求链接，或者使用第三方软件，如下载软件打开请求链接，Referer 为空

- 基于 Token 的防御

  - Token 的生成：后端生成随机密钥，输出到前端，前端获取密钥，按某算法生成 Token
    - 抓取源代码，仅能获取随机密钥，无法获得 Token
    - 还原了前端 Token 计算算法，依然需要获取随机密钥
  - Token 的使用：前端将帆布指纹发给后端，后端生成的随机密钥，绑定该指纹，并设置最大使用次数和过期时间
    - Token 与帆布指纹一一对应，从 A 环境获取的 Token，无法在 B 环境使用

- 基于帆布指纹的防御
  - 基于 AudioContext 声音指纹，生成跨浏览器帆布指纹，减少对容易伪造的参数依赖
  - 获取和使用 Token 时，都重新获取指纹，要求获取 Token 的指纹和使用 Token 的指纹一致
- 基于 CSP 内容安全策略的防御

  - 配置 `style-src` `script-src` `img-src` `connect-src` `workder-src` `manifest-src` 等的 `self` 策略，只允许加载同源文件，与同域 URL 通信
  - 配置 `script-src`
    - 避免使用 `unsafe-inline` 允许内联 `<script>` 和事件监听函数
    - 避免使用 `unsafe-eval` 允许使用 `eval` `Function` `setTimeout` `setInterval` 函数
    - 推荐使用 `nonce-{token}` 和 `{hash}` 策略，只允许 `token` 或 `hash` 一致的 `<script>` 标签执行

- 基于验证码的防御
- 对于能够获取的用于验证的信息有限，校验失败但可能存在误伤的请求，使用验证码、验证问题、图形验证、生物识别的方式，要求请求者手动验证合法性
  - 验证方式存在局限性
    - 图形验证码：可被图像识别，会使用软件截屏，传递给打打码平台人工验证
    - 验证问题：可建立验证问题和答案，会将问题传递给平台人工回答
    - 图形验证（标记图片、文字）：用户体验不佳
    - 图形验证改进版（旋转、点击图片，或拖拽滑块到空缺处）：基于操作方向、轨迹、速度，用户操作容易，体检较好
    - 生物识别：存在隐私风险，影响用户信任度
  - 一般操作，验证通过，在一定时间，一定次数内，不再重复验证
  - 敏感数据，风险操作，一个请求，一次验证

## 项目管理

### 您使用过哪些文档管理工具？

#### API 接口协作管理工具

- Swagger
- Spring
- Apizza

#### 文档协作工具

- 石墨文档
- 有道笔记 + 有道云协作
- 印象笔记

#### 自动文档生成

- apiDoc：根据 API 描述，自动生成文档
- jsDoc：根据 JS 注释，自动生成文档

### 对比 Git 和 SVN？

#### 架构

- Git：
  - 分布式，本地克隆版本库
  - 无网络依然可以操作分支，提交文件，查看历史记录
- SVN：
  - 集中式，代码一致性高
  - 依赖网络

#### 存储

- Git：按元数据，即描述文件的数据
- SVN：按文件

#### 分支

- Git：移动指针，创建切换快
- SVN：拷贝目录

#### 权限

- Git：
  - 经常按项目配置
  - 更适合开源
- SVN：
  - 经常按目录配置
  - 更适合内部开发

### 什么是敏捷开发？

#### 定义

- 以用户需求为核心，迭代、循序渐进的开发方法
- 大项目分成多个子项目，相互关联，可独立运行。整个开发过程中，软件保持可用

#### 特点

- 增量开发，快速响应变化
  - 对比瀑布开发，客户可以很快看到基础版本，更新需求，作出响应
- 优先实现最低成本，最大收益需求
- 软件为目标，高效沟通 > 图 > 文档

#### 技术实践

- 测试驱动开发 （Test-DrivenDevelopment）
  - 先编写单元测试用例，确保测试用例覆盖需求
  - 快速开发需求，通过测试用例
  - 已通过测试用例为前提
    - 重构代码，提升可读性、可维护性和性能
- 行为驱动开发 （BehaviorDriven Development）
- 持续集成 CI （Continuous Integration）
  - 开发提交新代码（提交合并请求 PR），立即构建、风格检查和单元测试
  - 只有构建成功，通过风格检查和单元测试的代码，才可被合并
- 持续部署 CD （Continuous Deployment）
  - 在持续交付的基础上，把部署到生产环境的过程自动化

#### Sprint

- 一个迭代即一个 Sprint，每个 Sprint 包含 1 个及以上 Build 版本
- 过程
  - 第一步：需求分析，排优先级将需求放入 Sprint
  - 第二步：规划测试，确定需求如何测试，质量目标是什么
  - 第三步：测试用例及评审，确定测试目标和顺序，明确开发方向
  - 第四步：拉新分支，开发及自测
  - 第五步：冒烟测试，未通过打回改 bug，通过合并主分支
  - 第六步：产品或需求方验证后，确认发布
- 会议
  - Sprint 计划会议
  - 每日站会
  - Sprint 评审会议
  - Sprint 回顾会议

### 敏捷开发的原则是什么？

- 快速迭代
  - 大项目分成小项目，大版本分成小版本
  - 需求、开发和测试更加简单快速
- 需求分析
  - 产品、测试、开发，包括运营等参与，明确需求优先级，增强参与感
- 需求文档
  - 以“用户故事”方法编写需求文档
  - 需求文档专注需求，而不是技术
- 产品原型
  - 用草图和模型直观地描述用户界面
- 沟通
  - 每日站会，面对面沟通
- 测试优先
  - 开发前明确测试目标，范围，顺序和关键点
  - 撰写测试用例并评审
  - 推荐测试驱动开发的技术实践
    - 先写单元测试用例再开发
    - 先安祖需求再优化性能、可读性和可维护性

## 数据库

### 什么是乐观锁，什么是悲观锁

#### 并发控制

- 需要保证并发情况下的数据准确性
- 保证一个用户的工作不会对另一个用户的工作产生不合理的影响
- 避免
  - 脏读：一个事务看见另一个事务未提交的数据
  - 不可重复读：一个事务两次读取到的数据内容不同，另一事务修改了数据
  - 幻读：一个事务两次读取到的数据条数不同，另一事务增删了数据

#### 乐观锁：多读 适用

- 仅在数据提交更新时，检测数据冲突。冲突时，采用竞争机制
- 依靠数据本身来保证数据正确性，如添加字段 version

#### 悲观锁：多写 适用

- 共享锁（读锁）：多个事务同一数据共享锁，只读不可写
- 排他锁（写锁）：一次仅一个事务可读写数据
  - 依赖数据库的锁机制，如 MySQL：select ... for update

### 什么是事务

#### （1）定义

访问并可能更新数据库中数据项的一个程序执行单元（Uint）

一条 SQL、一组 SQL 和 整个程序都可以是事务

#### （2）特点

- 原子性（atomicity）：不可分割，要么都做，要么都不做
- 一致性（consistency）：一个一致性状态变到另一个一致性状态
- 隔离性（isolation）：一个事务的执行不能被其他事务干扰，操作和数据使用不依赖和干扰其它并发事务
- 持久性（durability）：提交后的改变永久生效。不受故障或其它操作影响

#### （3）在 Mysql 中使用事务

```sql
# 关闭自动提交
SET autocommit = 0
# 或者开始一个事务
BEGIN
若干SQL语句
# 提交事务
COMMIT 对数据库所有修改都永久生效
若干SQL语句
# 回滚事务
ROLLBACK 结束当前事务，撤销所有未提交的更改
# 设置保存点
SAVEPOINT id 创建名为 id 的保存点
# 回滚事务到保存点
ROLLBACK TO id 把事务回滚到保存标记点
# 设置事务的隔离级别
SET TRANSACTION InnoDB 存储引擎提供事务的隔离级别有
(1) READ UNCOMMITTED
(2) READ COMMITED
(3) REPEATABLE READ
(4) SERIALIZABLE
```
